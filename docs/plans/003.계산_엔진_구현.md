# Phase 3: 계산 엔진 구현

## 개요
전기료 총액을 각 호실의 사용량에 따라 정확하게 분배하는 핵심 계산 엔진을 구현합니다. 비례 배분 방식을 사용하여 공정하고 투명한 요금 분배를 보장합니다.

## 목표
- 비례 배분 알고리즘 구현
- 원 단위 반올림 및 차액 조정
- 계산 검증 및 오차 처리
- 청구서 생성 및 저장

## 작업 내용

### 1. 계산 엔진 핵심 로직

#### 1.1 계산 공식
```
호실별 요금 계산 공식:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
사용 비율 = 호실 사용량 ÷ 전체 사용량

호실별 기본료 = 총 기본료 × 사용 비율
호실별 전력량요금 = 총 전력량요금 × 사용 비율
호실별 기후환경요금 = 총 기후환경요금 × 사용 비율
호실별 연료비조정액 = 총 연료비조정액 × 사용 비율
호실별 부가세 = 총 부가세 × 사용 비율
호실별 전력기금 = 총 전력기금 × 사용 비율
호실별 TV수신료 = 총 TV수신료 ÷ 입주 호실 수

호실별 총액 = 모든 항목의 합계 (원 단위 절사)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 2. 계산 엔진 구현

#### 2.1 계산 엔진 클래스 (`lib/calculation/calculator.ts`)
```typescript
import { KepcoInvoiceData, UnitUsageData } from '@/types/bill';

export interface UnitBillCalculation {
  unitId: number;
  unitNumber: string;
  usage: number;
  usageRate: number;
  basicFee: number;
  powerFee: number;
  climateFee: number;
  fuelFee: number;
  vat: number;
  powerFund: number;
  tvLicenseFee: number;
  roundDown: number;
  totalAmount: number;
}

export interface CalculationResult {
  unitBills: UnitBillCalculation[];
  totalCalculated: number;
  totalOriginal: number;
  difference: number;
  adjustments: Array<{
    unitNumber: string;
    amount: number;
    reason: string;
  }>;
}

export class ElectricityBillCalculator {
  private readonly TOLERANCE = 1; // 허용 오차 (원)

  /**
   * 메인 계산 메서드
   */
  calculate(
    invoice: KepcoInvoiceData,
    unitUsages: UnitUsageData[],
    unitInfo: Array<{ id: number; unitNumber: string; isOccupied: boolean }>
  ): CalculationResult {
    // 1. 입주 호실만 필터링
    const occupiedUnits = unitInfo.filter(u => u.isOccupied);
    const usageMap = new Map(unitUsages.map(u => [u.unitNumber, u]));
    
    // 2. 총 사용량 계산
    const totalUsage = unitUsages.reduce((sum, unit) => sum + unit.usage, 0);
    
    if (Math.abs(totalUsage - invoice.totalUsage) > 0.01) {
      console.warn(`총 사용량 불일치: Excel(${totalUsage}) vs PDF(${invoice.totalUsage})`);
    }

    // 3. 각 호실별 계산
    const unitBills: UnitBillCalculation[] = [];
    
    for (const unit of occupiedUnits) {
      const usage = usageMap.get(unit.unitNumber);
      if (!usage || usage.usage === 0) {
        // 사용량이 0인 경우 TV수신료만 부과
        unitBills.push({
          unitId: unit.id,
          unitNumber: unit.unitNumber,
          usage: 0,
          usageRate: 0,
          basicFee: 0,
          powerFee: 0,
          climateFee: 0,
          fuelFee: 0,
          vat: 0,
          powerFund: 0,
          tvLicenseFee: this.calculateTvFee(invoice.tvLicenseFee, occupiedUnits.length),
          roundDown: 0,
          totalAmount: this.calculateTvFee(invoice.tvLicenseFee, occupiedUnits.length),
        });
        continue;
      }

      const usageRate = usage.usage / totalUsage;
      
      // 각 항목별 계산 (소수점 유지)
      const basicFee = invoice.basicFee * usageRate;
      const powerFee = invoice.powerFee * usageRate;
      const climateFee = invoice.climateFee * usageRate;
      const fuelFee = invoice.fuelFee * usageRate;
      const vat = invoice.vat * usageRate;
      const powerFund = invoice.powerFund * usageRate;
      const tvLicenseFee = this.calculateTvFee(invoice.tvLicenseFee, occupiedUnits.length);
      
      // 소계 (원 단위 절사 전)
      const subtotal = basicFee + powerFee + climateFee + fuelFee + vat + powerFund + tvLicenseFee;
      
      // 원 단위 절사
      const totalAmount = Math.floor(subtotal / 10) * 10;
      const roundDown = totalAmount - subtotal;

      unitBills.push({
        unitId: unit.id,
        unitNumber: unit.unitNumber,
        usage: usage.usage,
        usageRate,
        basicFee: Math.round(basicFee),
        powerFee: Math.round(powerFee),
        climateFee: Math.round(climateFee),
        fuelFee: Math.round(fuelFee),
        vat: Math.round(vat),
        powerFund: Math.round(powerFund),
        tvLicenseFee,
        roundDown,
        totalAmount,
      });
    }

    // 4. 차액 조정
    const result = this.adjustDifference(unitBills, invoice.totalAmount);
    
    return result;
  }

  /**
   * TV 수신료 계산 (균등 분배)
   */
  private calculateTvFee(totalTvFee: number, occupiedCount: number): number {
    if (occupiedCount === 0) return 0;
    return Math.round(totalTvFee / occupiedCount);
  }

  /**
   * 차액 조정 알고리즘
   */
  private adjustDifference(
    unitBills: UnitBillCalculation[],
    targetTotal: number
  ): CalculationResult {
    const totalCalculated = unitBills.reduce((sum, bill) => sum + bill.totalAmount, 0);
    const difference = targetTotal - totalCalculated;
    const adjustments: Array<{ unitNumber: string; amount: number; reason: string }> = [];

    // 허용 오차 이내면 조정 불필요
    if (Math.abs(difference) <= this.TOLERANCE) {
      return {
        unitBills,
        totalCalculated,
        totalOriginal: targetTotal,
        difference,
        adjustments,
      };
    }

    // 차액 조정이 필요한 경우
    if (difference !== 0) {
      // 사용량이 많은 순으로 정렬
      const sortedBills = [...unitBills].sort((a, b) => b.usage - a.usage);
      
      // 조정할 금액 (10원 단위)
      const adjustmentUnit = difference > 0 ? 10 : -10;
      let remainingAdjustment = Math.abs(difference);
      let unitIndex = 0;

      while (remainingAdjustment >= 10 && unitIndex < sortedBills.length) {
        const bill = sortedBills[unitIndex];
        
        // 해당 호실에 조정 금액 적용
        bill.totalAmount += adjustmentUnit;
        bill.roundDown -= adjustmentUnit;
        remainingAdjustment -= 10;

        adjustments.push({
          unitNumber: bill.unitNumber,
          amount: adjustmentUnit,
          reason: '총액 일치를 위한 조정',
        });

        // 다음 호실로 순환
        unitIndex = (unitIndex + 1) % sortedBills.length;
      }
    }

    const finalTotal = unitBills.reduce((sum, bill) => sum + bill.totalAmount, 0);

    return {
      unitBills,
      totalCalculated: finalTotal,
      totalOriginal: targetTotal,
      difference: targetTotal - finalTotal,
      adjustments,
    };
  }

  /**
   * 계산 검증
   */
  validate(result: CalculationResult): {
    isValid: boolean;
    errors: string[];
    warnings: string[];
  } {
    const errors: string[] = [];
    const warnings: string[] = [];

    // 1. 총액 일치 검증
    if (Math.abs(result.difference) > this.TOLERANCE) {
      errors.push(`총액 불일치: 차이 ${result.difference}원`);
    }

    // 2. 음수 금액 체크
    for (const bill of result.unitBills) {
      if (bill.totalAmount < 0) {
        errors.push(`${bill.unitNumber}호: 음수 청구액 (${bill.totalAmount}원)`);
      }
    }

    // 3. 사용량 대비 요금 이상치 체크
    const avgRate = result.totalOriginal / result.unitBills.reduce((sum, b) => sum + b.usage, 0);
    for (const bill of result.unitBills) {
      if (bill.usage > 0) {
        const rate = bill.totalAmount / bill.usage;
        if (rate > avgRate * 2) {
          warnings.push(`${bill.unitNumber}호: 평균 대비 높은 단가`);
        }
      }
    }

    // 4. 조정 금액 체크
    if (result.adjustments.length > 0) {
      const totalAdjustment = result.adjustments.reduce((sum, a) => sum + a.amount, 0);
      warnings.push(`${result.adjustments.length}개 호실에 총 ${totalAdjustment}원 조정`);
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
    };
  }
}
```

### 3. 계산 서비스 구현

#### 3.1 계산 서비스 (`lib/services/calculation-service.ts`)
```typescript
import { ElectricityBillCalculator, CalculationResult } from '@/lib/calculation/calculator';
import { KepcoInvoiceData, UnitUsageData } from '@/types/bill';
import { query, execute, transaction } from '@/lib/db-utils';
import { RowDataPacket, ResultSetHeader } from 'mysql2';

interface UnitRow extends RowDataPacket {
  id: number;
  unit_number: string;
  status: 'occupied' | 'vacant';
}

export class CalculationService {
  private calculator: ElectricityBillCalculator;

  constructor() {
    this.calculator = new ElectricityBillCalculator();
  }

  /**
   * 청구서 생성 및 저장
   */
  async createMonthlyBill(
    invoice: KepcoInvoiceData,
    unitUsages: UnitUsageData[],
    userId: number
  ): Promise<{ success: boolean; billId?: number; error?: string }> {
    try {
      return await transaction(async (connection) => {
        // 1. 중복 체크
        const [existing] = await connection.execute<RowDataPacket[]>(
          'SELECT id FROM monthly_bills WHERE bill_year = ? AND bill_month = ?',
          [
            invoice.billingPeriod.start.getFullYear(),
            invoice.billingPeriod.start.getMonth() + 1,
          ]
        );

        if (existing.length > 0) {
          throw new Error('해당 월의 청구서가 이미 존재합니다.');
        }

        // 2. 호실 정보 조회
        const units = await connection.execute<UnitRow[]>(
          'SELECT id, unit_number, status FROM units'
        );
        
        const unitInfo = units[0].map(u => ({
          id: u.id,
          unitNumber: u.unit_number,
          isOccupied: u.status === 'occupied',
        }));

        // 3. 계산 실행
        const result = this.calculator.calculate(invoice, unitUsages, unitInfo);
        
        // 4. 계산 검증
        const validation = this.calculator.validate(result);
        if (!validation.isValid) {
          throw new Error(`계산 오류: ${validation.errors.join(', ')}`);
        }

        // 5. monthly_bills 저장
        const [monthlyBillResult] = await connection.execute<ResultSetHeader>(
          `INSERT INTO monthly_bills (
            bill_year, bill_month, billing_period_start, billing_period_end,
            total_usage, total_amount, basic_fee, power_fee, climate_fee,
            fuel_fee, vat, power_fund, tv_license_fee, round_down,
            created_by
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            invoice.billingPeriod.start.getFullYear(),
            invoice.billingPeriod.start.getMonth() + 1,
            invoice.billingPeriod.start,
            invoice.billingPeriod.end,
            invoice.totalUsage,
            invoice.totalAmount,
            invoice.basicFee,
            invoice.powerFee,
            invoice.climateFee,
            invoice.fuelFee,
            invoice.vat,
            invoice.powerFund,
            invoice.tvLicenseFee,
            invoice.roundDown,
            userId,
          ]
        );

        const monthlyBillId = monthlyBillResult.insertId;

        // 6. unit_bills 저장
        for (const bill of result.unitBills) {
          const usage = unitUsages.find(u => u.unitNumber === bill.unitNumber);
          
          await connection.execute(
            `INSERT INTO unit_bills (
              monthly_bill_id, unit_id, previous_reading, current_reading,
              usage_amount, usage_rate, basic_fee, power_fee, climate_fee,
              fuel_fee, vat, power_fund, tv_license_fee, round_down,
              total_amount, payment_status
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
              monthlyBillId,
              bill.unitId,
              usage?.previousReading || 0,
              usage?.currentReading || 0,
              bill.usage,
              bill.usageRate,
              bill.basicFee,
              bill.powerFee,
              bill.climateFee,
              bill.fuelFee,
              bill.vat,
              bill.powerFund,
              bill.tvLicenseFee,
              bill.roundDown,
              bill.totalAmount,
              'pending',
            ]
          );
        }

        // 7. 조정 내역 로깅
        if (result.adjustments.length > 0) {
          console.log('청구서 조정 내역:', result.adjustments);
        }

        return {
          success: true,
          billId: monthlyBillId,
        };
      });
    } catch (error) {
      console.error('청구서 생성 오류:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * 청구서 재계산
   */
  async recalculateBill(
    monthlyBillId: number,
    userId: number
  ): Promise<{ success: boolean; error?: string }> {
    try {
      return await transaction(async (connection) => {
        // 1. 기존 청구서 정보 조회
        const [bills] = await connection.execute<RowDataPacket[]>(
          `SELECT * FROM monthly_bills WHERE id = ?`,
          [monthlyBillId]
        );

        if (bills.length === 0) {
          throw new Error('청구서를 찾을 수 없습니다.');
        }

        const bill = bills[0];
        
        // 2. 기존 호실별 사용량 조회
        const [unitBills] = await connection.execute<RowDataPacket[]>(
          `SELECT ub.*, u.unit_number 
           FROM unit_bills ub
           JOIN units u ON ub.unit_id = u.id
           WHERE ub.monthly_bill_id = ?`,
          [monthlyBillId]
        );

        // 3. 데이터 변환
        const invoice: KepcoInvoiceData = {
          customerNumber: '',
          invoiceNumber: '',
          billingPeriod: {
            start: bill.billing_period_start,
            end: bill.billing_period_end,
          },
          previousReading: 0,
          currentReading: 0,
          totalUsage: bill.total_usage,
          basicFee: bill.basic_fee,
          powerFee: bill.power_fee,
          climateFee: bill.climate_fee,
          fuelFee: bill.fuel_fee,
          vat: bill.vat,
          powerFund: bill.power_fund,
          tvLicenseFee: bill.tv_license_fee,
          roundDown: bill.round_down,
          totalAmount: bill.total_amount,
          dueDate: new Date(),
          issueDate: new Date(),
        };

        const unitUsages: UnitUsageData[] = unitBills.map(ub => ({
          unitNumber: ub.unit_number,
          previousReading: ub.previous_reading,
          currentReading: ub.current_reading,
          usage: ub.usage_amount,
        }));

        // 4. 호실 정보 조회
        const [units] = await connection.execute<UnitRow[]>(
          'SELECT id, unit_number, status FROM units'
        );
        
        const unitInfo = units.map(u => ({
          id: u.id,
          unitNumber: u.unit_number,
          isOccupied: u.status === 'occupied',
        }));

        // 5. 재계산
        const result = this.calculator.calculate(invoice, unitUsages, unitInfo);
        
        // 6. 계산 검증
        const validation = this.calculator.validate(result);
        if (!validation.isValid) {
          throw new Error(`계산 오류: ${validation.errors.join(', ')}`);
        }

        // 7. 기존 unit_bills 삭제
        await connection.execute(
          'DELETE FROM unit_bills WHERE monthly_bill_id = ?',
          [monthlyBillId]
        );

        // 8. 새로운 unit_bills 저장
        for (const bill of result.unitBills) {
          const usage = unitUsages.find(u => u.unitNumber === bill.unitNumber);
          
          await connection.execute(
            `INSERT INTO unit_bills (
              monthly_bill_id, unit_id, previous_reading, current_reading,
              usage_amount, usage_rate, basic_fee, power_fee, climate_fee,
              fuel_fee, vat, power_fund, tv_license_fee, round_down,
              total_amount, payment_status
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
              monthlyBillId,
              bill.unitId,
              usage?.previousReading || 0,
              usage?.currentReading || 0,
              bill.usage,
              bill.usageRate,
              bill.basicFee,
              bill.powerFee,
              bill.climateFee,
              bill.fuelFee,
              bill.vat,
              bill.powerFund,
              bill.tvLicenseFee,
              bill.roundDown,
              bill.totalAmount,
              'pending',
            ]
          );
        }

        return { success: true };
      });
    } catch (error) {
      console.error('재계산 오류:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }
}
```

### 4. API 엔드포인트

#### 4.1 계산 API (`app/api/calculate/route.ts`)
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { CalculationService } from '@/lib/services/calculation-service';

export async function POST(request: NextRequest) {
  try {
    const userId = request.headers.get('x-user-id');
    const userRole = request.headers.get('x-user-role');
    
    if (!userId || userRole !== 'admin') {
      return NextResponse.json(
        { success: false, error: '권한이 없습니다.' },
        { status: 403 }
      );
    }

    const { invoice, unitUsages } = await request.json();
    
    if (!invoice || !unitUsages) {
      return NextResponse.json(
        { success: false, error: '필수 데이터가 없습니다.' },
        { status: 400 }
      );
    }

    const service = new CalculationService();
    const result = await service.createMonthlyBill(
      invoice,
      unitUsages,
      parseInt(userId)
    );

    if (result.success) {
      return NextResponse.json({
        success: true,
        billId: result.billId,
        message: '청구서가 성공적으로 생성되었습니다.',
      });
    } else {
      return NextResponse.json(
        { success: false, error: result.error },
        { status: 400 }
      );
    }
  } catch (error) {
    console.error('계산 API 오류:', error);
    return NextResponse.json(
      { success: false, error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
```

#### 4.2 재계산 API (`app/api/calculate/recalculate/route.ts`)
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { CalculationService } from '@/lib/services/calculation-service';

export async function POST(request: NextRequest) {
  try {
    const userId = request.headers.get('x-user-id');
    const userRole = request.headers.get('x-user-role');
    
    if (!userId || userRole !== 'admin') {
      return NextResponse.json(
        { success: false, error: '권한이 없습니다.' },
        { status: 403 }
      );
    }

    const { billId } = await request.json();
    
    if (!billId) {
      return NextResponse.json(
        { success: false, error: '청구서 ID가 필요합니다.' },
        { status: 400 }
      );
    }

    const service = new CalculationService();
    const result = await service.recalculateBill(billId, parseInt(userId));

    if (result.success) {
      return NextResponse.json({
        success: true,
        message: '청구서가 재계산되었습니다.',
      });
    } else {
      return NextResponse.json(
        { success: false, error: result.error },
        { status: 400 }
      );
    }
  } catch (error) {
    console.error('재계산 API 오류:', error);
    return NextResponse.json(
      { success: false, error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
```

## 테스트 체크리스트

- [ ] 비례 배분 계산 정확도
- [ ] 원 단위 절사 처리
- [ ] 차액 조정 알고리즘
- [ ] 총액 일치 검증 (±1원)
- [ ] TV수신료 균등 분배
- [ ] 빈 호실 제외 처리
- [ ] 사용량 0인 호실 처리
- [ ] 음수 연료비조정액 처리
- [ ] 대량 데이터 처리 성능
- [ ] 트랜잭션 롤백 처리

## 성능 최적화

1. **배치 처리**
   - 호실별 계산을 배치로 처리
   - DB 삽입 시 bulk insert 사용

2. **메모리 관리**
   - 대량 계산 시 스트리밍 처리
   - 불필요한 객체 생성 최소화

3. **캐싱**
   - 호실 정보 캐싱
   - 계산 결과 임시 캐싱

## 예상 소요 시간
- 계산 엔진 핵심 로직: 3시간
- 차액 조정 알고리즘: 2시간
- 서비스 레이어 구현: 2시간
- API 엔드포인트: 1시간
- 테스트 및 검증: 2시간
- **총 예상 시간: 10시간**

## 다음 단계
Phase 4: 대시보드 UI 개발로 진행