# Phase 2: PDF/Excel 파싱 API

## 개요
한전 전기료 청구서 PDF와 호실별 사용량 Excel 파일을 업로드하고 자동으로 데이터를 추출하는 API를 구현합니다. 파일은 메모리에서만 처리하고 저장하지 않아 완전 무료로 운영합니다.

## 목표
- PDF 파일에서 청구 정보 자동 추출
- Excel 파일에서 호실별 사용량 데이터 파싱
- 데이터 검증 및 오류 처리
- 수동 입력 대체 방안 제공

## 작업 내용

### 1. 필요 패키지 설치

```bash
npm install pdf-parse xlsx multer
npm install --save-dev @types/multer
```

### 2. 타입 정의

#### 2.1 청구서 데이터 타입 (`types/bill.ts`)
```typescript
export interface KepcoInvoiceData {
  // 기본 정보
  customerNumber: string;        // 고객번호
  invoiceNumber: string;         // 청구서번호
  billingPeriod: {
    start: Date;
    end: Date;
  };
  
  // 사용량 정보
  previousReading: number;       // 전월 지침
  currentReading: number;        // 당월 지침
  totalUsage: number;           // 총 사용량 (kWh)
  
  // 요금 상세
  basicFee: number;             // 기본요금
  powerFee: number;             // 전력량요금
  climateFee: number;           // 기후환경요금
  fuelFee: number;              // 연료비조정액
  vat: number;                  // 부가가치세
  powerFund: number;            // 전력산업기반기금
  tvLicenseFee: number;         // TV수신료
  roundDown: number;            // 단수처리
  
  // 총액
  totalAmount: number;          // 청구금액
  
  // 기타
  dueDate: Date;                // 납기일
  issueDate: Date;              // 발행일
}

export interface UnitUsageData {
  unitNumber: string;
  previousReading: number;
  currentReading: number;
  usage: number;
  notes?: string;
}

export interface ParseResult<T> {
  success: boolean;
  data?: T;
  error?: string;
  warnings?: string[];
}
```

### 3. PDF 파싱 모듈

#### 3.1 PDF 파서 구현 (`lib/parsers/pdf-parser.ts`)
```typescript
import pdf from 'pdf-parse';
import { KepcoInvoiceData, ParseResult } from '@/types/bill';

export class KepcoInvoiceParser {
  private extractNumber(text: string, pattern: RegExp): number {
    const match = text.match(pattern);
    if (!match) return 0;
    
    // 쉼표 제거 후 숫자 변환
    const cleanNumber = match[1].replace(/,/g, '').replace(/원/g, '');
    return parseFloat(cleanNumber) || 0;
  }

  private extractDate(text: string, pattern: RegExp): Date | null {
    const match = text.match(pattern);
    if (!match) return null;
    
    // YYYY.MM.DD 형식 파싱
    const [year, month, day] = match[1].split('.').map(Number);
    return new Date(year, month - 1, day);
  }

  async parse(buffer: Buffer): Promise<ParseResult<KepcoInvoiceData>> {
    try {
      const data = await pdf(buffer);
      const text = data.text;
      
      // 한전 청구서 패턴 정의
      const patterns = {
        customerNumber: /고객번호[\s:]*(\d+)/,
        invoiceNumber: /청구서번호[\s:]*(\d+)/,
        billingPeriodStart: /사용기간[\s:]*(\d{4}\.\d{2}\.\d{2})/,
        billingPeriodEnd: /~[\s]*(\d{4}\.\d{2}\.\d{2})/,
        previousReading: /전월지침[\s:]*(\d+)/,
        currentReading: /당월지침[\s:]*(\d+)/,
        totalUsage: /사용량[\s:]*(\d+(?:,\d{3})*)\s*kWh/,
        basicFee: /기본요금[\s:]*(\d+(?:,\d{3})*)/,
        powerFee: /전력량요금[\s:]*(\d+(?:,\d{3})*)/,
        climateFee: /기후환경요금[\s:]*(\d+(?:,\d{3})*)/,
        fuelFee: /연료비조정액[\s:]*(-?\d+(?:,\d{3})*)/,
        vat: /부가가치세[\s:]*(\d+(?:,\d{3})*)/,
        powerFund: /전력산업기반기금[\s:]*(\d+(?:,\d{3})*)/,
        tvLicenseFee: /TV수신료[\s:]*(\d+(?:,\d{3})*)/,
        totalAmount: /청구금액[\s:]*(\d+(?:,\d{3})*)/,
        dueDate: /납기일[\s:]*(\d{4}\.\d{2}\.\d{2})/,
      };

      // 데이터 추출
      const invoice: KepcoInvoiceData = {
        customerNumber: text.match(patterns.customerNumber)?.[1] || '',
        invoiceNumber: text.match(patterns.invoiceNumber)?.[1] || '',
        billingPeriod: {
          start: this.extractDate(text, patterns.billingPeriodStart)!,
          end: this.extractDate(text, patterns.billingPeriodEnd)!,
        },
        previousReading: this.extractNumber(text, patterns.previousReading),
        currentReading: this.extractNumber(text, patterns.currentReading),
        totalUsage: this.extractNumber(text, patterns.totalUsage),
        basicFee: this.extractNumber(text, patterns.basicFee),
        powerFee: this.extractNumber(text, patterns.powerFee),
        climateFee: this.extractNumber(text, patterns.climateFee),
        fuelFee: this.extractNumber(text, patterns.fuelFee),
        vat: this.extractNumber(text, patterns.vat),
        powerFund: this.extractNumber(text, patterns.powerFund),
        tvLicenseFee: this.extractNumber(text, patterns.tvLicenseFee),
        roundDown: 0, // 계산 시 자동 처리
        totalAmount: this.extractNumber(text, patterns.totalAmount),
        dueDate: this.extractDate(text, patterns.dueDate)!,
        issueDate: new Date(),
      };

      // 데이터 검증
      const warnings: string[] = [];
      
      // 필수 필드 검증
      if (!invoice.totalAmount) {
        warnings.push('총 청구금액을 찾을 수 없습니다.');
      }
      if (!invoice.totalUsage) {
        warnings.push('총 사용량을 찾을 수 없습니다.');
      }

      // 합계 검증
      const calculatedTotal = 
        invoice.basicFee +
        invoice.powerFee +
        invoice.climateFee +
        invoice.fuelFee +
        invoice.vat +
        invoice.powerFund +
        invoice.tvLicenseFee;

      const difference = Math.abs(calculatedTotal - invoice.totalAmount);
      if (difference > 10) {
        warnings.push(`계산된 합계와 청구금액의 차이: ${difference}원`);
      }

      return {
        success: true,
        data: invoice,
        warnings: warnings.length > 0 ? warnings : undefined,
      };
    } catch (error) {
      return {
        success: false,
        error: `PDF 파싱 실패: ${error.message}`,
      };
    }
  }
}
```

### 4. Excel 파싱 모듈

#### 4.1 Excel 파서 구현 (`lib/parsers/excel-parser.ts`)
```typescript
import * as XLSX from 'xlsx';
import { UnitUsageData, ParseResult } from '@/types/bill';

export class UnitUsageParser {
  private findHeaderRow(sheet: any, headers: string[]): number {
    const range = XLSX.utils.decode_range(sheet['!ref']);
    
    for (let row = 0; row <= Math.min(10, range.e.r); row++) {
      let matchCount = 0;
      for (let col = 0; col <= range.e.c; col++) {
        const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
        const cell = sheet[cellAddress];
        if (cell && headers.includes(cell.v?.toString().trim())) {
          matchCount++;
        }
      }
      if (matchCount >= headers.length * 0.5) {
        return row;
      }
    }
    return -1;
  }

  private parseSheet(sheet: any): UnitUsageData[] {
    const data: UnitUsageData[] = [];
    
    // 가능한 헤더 패턴들
    const headerPatterns = [
      ['호실', '전월지침', '당월지침', '사용량'],
      ['호수', '전월', '당월', '사용'],
      ['Unit', 'Previous', 'Current', 'Usage'],
    ];

    let headerRow = -1;
    let headers: string[] = [];

    // 헤더 찾기
    for (const pattern of headerPatterns) {
      headerRow = this.findHeaderRow(sheet, pattern);
      if (headerRow !== -1) {
        headers = pattern;
        break;
      }
    }

    if (headerRow === -1) {
      throw new Error('Excel 파일에서 헤더를 찾을 수 없습니다.');
    }

    // 헤더 컬럼 인덱스 찾기
    const range = XLSX.utils.decode_range(sheet['!ref']);
    const columnMap: { [key: string]: number } = {};

    for (let col = 0; col <= range.e.c; col++) {
      const cellAddress = XLSX.utils.encode_cell({ r: headerRow, c: col });
      const cell = sheet[cellAddress];
      if (cell?.v) {
        const value = cell.v.toString().trim();
        if (value.includes('호실') || value.includes('호수') || value === 'Unit') {
          columnMap.unitNumber = col;
        } else if (value.includes('전월') || value === 'Previous') {
          columnMap.previousReading = col;
        } else if (value.includes('당월') || value === 'Current') {
          columnMap.currentReading = col;
        } else if (value.includes('사용') || value === 'Usage') {
          columnMap.usage = col;
        } else if (value.includes('비고') || value === 'Notes') {
          columnMap.notes = col;
        }
      }
    }

    // 데이터 파싱
    for (let row = headerRow + 1; row <= range.e.r; row++) {
      const unitCell = sheet[XLSX.utils.encode_cell({ r: row, c: columnMap.unitNumber })];
      
      if (!unitCell?.v) continue; // 빈 행 스킵

      const unitData: UnitUsageData = {
        unitNumber: unitCell.v.toString().trim(),
        previousReading: 0,
        currentReading: 0,
        usage: 0,
      };

      // 각 필드 파싱
      if (columnMap.previousReading !== undefined) {
        const cell = sheet[XLSX.utils.encode_cell({ r: row, c: columnMap.previousReading })];
        unitData.previousReading = parseFloat(cell?.v) || 0;
      }

      if (columnMap.currentReading !== undefined) {
        const cell = sheet[XLSX.utils.encode_cell({ r: row, c: columnMap.currentReading })];
        unitData.currentReading = parseFloat(cell?.v) || 0;
      }

      if (columnMap.usage !== undefined) {
        const cell = sheet[XLSX.utils.encode_cell({ r: row, c: columnMap.usage })];
        unitData.usage = parseFloat(cell?.v) || 0;
      } else {
        // 사용량이 없으면 계산
        unitData.usage = unitData.currentReading - unitData.previousReading;
      }

      if (columnMap.notes !== undefined) {
        const cell = sheet[XLSX.utils.encode_cell({ r: row, c: columnMap.notes })];
        unitData.notes = cell?.v?.toString() || '';
      }

      // 유효성 검증
      if (unitData.unitNumber && unitData.usage >= 0) {
        data.push(unitData);
      }
    }

    return data;
  }

  async parse(buffer: Buffer): Promise<ParseResult<UnitUsageData[]>> {
    try {
      const workbook = XLSX.read(buffer, { type: 'buffer' });
      
      if (workbook.SheetNames.length === 0) {
        return {
          success: false,
          error: 'Excel 파일에 시트가 없습니다.',
        };
      }

      // 첫 번째 시트 사용
      const sheetName = workbook.SheetNames[0];
      const sheet = workbook.Sheets[sheetName];
      
      const data = this.parseSheet(sheet);
      
      const warnings: string[] = [];
      
      // 데이터 검증
      if (data.length === 0) {
        return {
          success: false,
          error: '유효한 데이터를 찾을 수 없습니다.',
        };
      }

      // 중복 호실 체크
      const unitNumbers = new Set<string>();
      const duplicates: string[] = [];
      
      for (const unit of data) {
        if (unitNumbers.has(unit.unitNumber)) {
          duplicates.push(unit.unitNumber);
        }
        unitNumbers.add(unit.unitNumber);
      }
      
      if (duplicates.length > 0) {
        warnings.push(`중복된 호실: ${duplicates.join(', ')}`);
      }

      // 음수 사용량 체크
      const negativeUsage = data.filter(u => u.usage < 0);
      if (negativeUsage.length > 0) {
        warnings.push(`음수 사용량 호실: ${negativeUsage.map(u => u.unitNumber).join(', ')}`);
      }

      return {
        success: true,
        data,
        warnings: warnings.length > 0 ? warnings : undefined,
      };
    } catch (error) {
      return {
        success: false,
        error: `Excel 파싱 실패: ${error.message}`,
      };
    }
  }
}
```

### 5. 데이터베이스 저장 로직

#### 5.1 파싱 데이터 저장 서비스 (`lib/services/parse-storage.ts`)
```typescript
import { execute, query, transaction } from '@/lib/db-utils';
import crypto from 'crypto';
import { KepcoInvoiceData, UnitUsageData } from '@/types/bill';

export class ParseStorageService {
  /**
   * PDF 파싱 데이터 저장
   */
  async savePdfData(
    data: KepcoInvoiceData,
    fileName: string,
    fileBuffer: Buffer,
    rawText: string,
    warnings?: string[],
    userId?: number
  ) {
    // 파일 해시 생성 (중복 방지)
    const fileHash = crypto.createHash('sha256')
      .update(fileBuffer)
      .digest('hex');

    // 중복 체크
    const existing = await query(
      'SELECT id FROM parsed_pdf_data WHERE file_hash = ?',
      [fileHash]
    );

    if (existing.length > 0) {
      throw new Error('동일한 PDF 파일이 이미 처리되었습니다.');
    }

    // 데이터 저장
    const result = await execute(`
      INSERT INTO parsed_pdf_data (
        file_name, file_hash, customer_number, invoice_number,
        billing_period_start, billing_period_end,
        previous_reading, current_reading, total_usage,
        basic_fee, power_fee, climate_fee, fuel_fee,
        vat, power_fund, tv_license_fee, round_down,
        total_amount, due_date, raw_text, parsed_data,
        parse_warnings, parsed_by
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      fileName, fileHash, data.customerNumber, data.invoiceNumber,
      data.billingPeriod.start, data.billingPeriod.end,
      data.previousReading, data.currentReading, data.totalUsage,
      data.basicFee, data.powerFee, data.climateFee, data.fuelFee,
      data.vat, data.powerFund, data.tvLicenseFee, data.roundDown,
      data.totalAmount, data.dueDate, rawText,
      JSON.stringify(data),
      warnings ? JSON.stringify(warnings) : null,
      userId || null
    ]);

    return result.insertId;
  }

  /**
   * Excel 파싱 데이터 저장
   */
  async saveExcelData(
    data: UnitUsageData[],
    fileName: string,
    fileBuffer: Buffer,
    sheetName: string,
    columnMapping: any,
    warnings?: string[],
    userId?: number
  ) {
    // 파일 해시 생성
    const fileHash = crypto.createHash('sha256')
      .update(fileBuffer)
      .digest('hex');

    // 중복 체크
    const existing = await query(
      'SELECT id FROM parsed_excel_data WHERE file_hash = ?',
      [fileHash]
    );

    if (existing.length > 0) {
      throw new Error('동일한 Excel 파일이 이미 처리되었습니다.');
    }

    // 통계 계산
    const totalUnits = data.length;
    const totalUsage = data.reduce((sum, unit) => sum + unit.usage, 0);
    const averageUsage = totalUsage / totalUnits;

    // 데이터 저장
    const result = await execute(`
      INSERT INTO parsed_excel_data (
        file_name, file_hash, sheet_name,
        total_units, total_usage, average_usage,
        unit_data, column_mapping, parse_warnings, parsed_by
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      fileName, fileHash, sheetName,
      totalUnits, totalUsage, averageUsage,
      JSON.stringify(data),
      JSON.stringify(columnMapping),
      warnings ? JSON.stringify(warnings) : null,
      userId || null
    ]);

    return result.insertId;
  }

  /**
   * 파싱 이력 조회
   */
  async getParseHistory(type: 'pdf' | 'excel', limit: number = 10) {
    const table = type === 'pdf' ? 'parsed_pdf_data' : 'parsed_excel_data';
    
    const results = await query(`
      SELECT id, file_name, parsed_at, parse_warnings,
             ${type === 'pdf' ? 'total_amount, billing_period_start, billing_period_end' : 'total_units, total_usage, average_usage'}
      FROM ${table}
      ORDER BY parsed_at DESC
      LIMIT ?
    `, [limit]);

    return results.map(row => ({
      ...row,
      parse_warnings: row.parse_warnings ? JSON.parse(row.parse_warnings) : null
    }));
  }

  /**
   * 월별 청구서와 연결
   */
  async linkToMonthlyBill(
    pdfId: number,
    excelId: number,
    year: number,
    month: number
  ) {
    return await transaction(async (connection) => {
      // PDF 데이터 가져오기
      const [pdfData] = await connection.query(
        'SELECT * FROM parsed_pdf_data WHERE id = ?',
        [pdfId]
      );

      if (!pdfData) {
        throw new Error('PDF 데이터를 찾을 수 없습니다.');
      }

      // Excel 데이터 가져오기
      const [excelData] = await connection.query(
        'SELECT * FROM parsed_excel_data WHERE id = ?',
        [excelId]
      );

      if (!excelData) {
        throw new Error('Excel 데이터를 찾을 수 없습니다.');
      }

      // monthly_bills 레코드 생성 또는 업데이트
      const [result] = await connection.query(`
        INSERT INTO monthly_bills (
          bill_year, bill_month,
          billing_period_start, billing_period_end,
          total_usage, total_amount,
          basic_fee, power_fee, climate_fee, fuel_fee,
          vat, power_fund, tv_license_fee, round_down,
          pdf_file_name, excel_file_name
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON DUPLICATE KEY UPDATE
          billing_period_start = VALUES(billing_period_start),
          billing_period_end = VALUES(billing_period_end),
          total_usage = VALUES(total_usage),
          total_amount = VALUES(total_amount),
          basic_fee = VALUES(basic_fee),
          power_fee = VALUES(power_fee),
          climate_fee = VALUES(climate_fee),
          fuel_fee = VALUES(fuel_fee),
          vat = VALUES(vat),
          power_fund = VALUES(power_fund),
          tv_license_fee = VALUES(tv_license_fee),
          round_down = VALUES(round_down),
          pdf_file_name = VALUES(pdf_file_name),
          excel_file_name = VALUES(excel_file_name)
      `, [
        year, month,
        pdfData.billing_period_start, pdfData.billing_period_end,
        pdfData.total_usage, pdfData.total_amount,
        pdfData.basic_fee, pdfData.power_fee, pdfData.climate_fee, pdfData.fuel_fee,
        pdfData.vat, pdfData.power_fund, pdfData.tv_license_fee, pdfData.round_down,
        pdfData.file_name, excelData.file_name
      ]);

      const monthlyBillId = result.insertId || result.affectedRows;

      // parsed_pdf_data와 parsed_excel_data 업데이트
      await connection.query(
        'UPDATE parsed_pdf_data SET monthly_bill_id = ? WHERE id = ?',
        [monthlyBillId, pdfId]
      );

      await connection.query(
        'UPDATE parsed_excel_data SET monthly_bill_id = ? WHERE id = ?',
        [monthlyBillId, excelId]
      );

      return monthlyBillId;
    });
  }
}
```

### 6. API 엔드포인트 구현

#### 6.1 Multer 설정 (`lib/upload.ts`)
```typescript
import multer from 'multer';

// 메모리 스토리지 사용 (파일 저장 안 함)
const storage = multer.memoryStorage();

export const upload = multer({
  storage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB 제한
  },
  fileFilter: (req, file, cb) => {
    // 파일 타입 검증
    if (file.fieldname === 'pdf') {
      if (file.mimetype === 'application/pdf') {
        cb(null, true);
      } else {
        cb(new Error('PDF 파일만 업로드 가능합니다.'));
      }
    } else if (file.fieldname === 'excel') {
      const validTypes = [
        'application/vnd.ms-excel',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      ];
      if (validTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error('Excel 파일만 업로드 가능합니다.'));
      }
    } else {
      cb(new Error('잘못된 필드명입니다.'));
    }
  },
});
```

#### 6.2 PDF 업로드 및 저장 API (`app/api/parse/pdf/route.ts`)
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { KepcoInvoiceParser } from '@/lib/parsers/pdf-parser';

export async function POST(request: NextRequest) {
  try {
    // 인증 체크
    const userId = request.headers.get('x-user-id');
    const userRole = request.headers.get('x-user-role');
    
    if (!userId || userRole !== 'admin') {
      return NextResponse.json(
        { success: false, error: '권한이 없습니다.' },
        { status: 403 }
      );
    }

    // FormData에서 파일 추출
    const formData = await request.formData();
    const file = formData.get('pdf') as File;
    
    if (!file) {
      return NextResponse.json(
        { success: false, error: 'PDF 파일이 없습니다.' },
        { status: 400 }
      );
    }

    // 파일을 Buffer로 변환
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    // PDF 파싱
    const parser = new KepcoInvoiceParser();
    const result = await parser.parse(buffer);

    if (!result.success) {
      return NextResponse.json(
        { success: false, error: result.error },
        { status: 400 }
      );
    }

    // DB에 파싱 데이터 저장
    const storageService = new ParseStorageService();
    const pdfId = await storageService.savePdfData(
      result.data!,
      file.name,
      buffer,
      '', // raw text는 파서에서 추출
      result.warnings,
      parseInt(userId)
    );

    return NextResponse.json({
      success: true,
      data: result.data,
      pdfId,
      warnings: result.warnings,
      message: 'PDF 파싱 및 저장이 완료되었습니다.',
    });
  } catch (error) {
    console.error('PDF upload error:', error);
    return NextResponse.json(
      { success: false, error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
```

#### 6.3 Excel 업로드 및 저장 API (`app/api/parse/excel/route.ts`)
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { UnitUsageParser } from '@/lib/parsers/excel-parser';

export async function POST(request: NextRequest) {
  try {
    // 인증 체크
    const userId = request.headers.get('x-user-id');
    const userRole = request.headers.get('x-user-role');
    
    if (!userId || userRole !== 'admin') {
      return NextResponse.json(
        { success: false, error: '권한이 없습니다.' },
        { status: 403 }
      );
    }

    // FormData에서 파일 추출
    const formData = await request.formData();
    const file = formData.get('excel') as File;
    
    if (!file) {
      return NextResponse.json(
        { success: false, error: 'Excel 파일이 없습니다.' },
        { status: 400 }
      );
    }

    // 파일을 Buffer로 변환
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);

    // Excel 파싱
    const parser = new UnitUsageParser();
    const result = await parser.parse(buffer);

    if (!result.success) {
      return NextResponse.json(
        { success: false, error: result.error },
        { status: 400 }
      );
    }

    // DB에 파싱 데이터 저장
    const storageService = new ParseStorageService();
    const excelId = await storageService.saveExcelData(
      result.data!,
      file.name,
      buffer,
      'Sheet1', // 시트명은 파서에서 추출
      {}, // 컬럼 매핑 정보
      result.warnings,
      parseInt(userId)
    );

    // 총 사용량 계산
    const totalUsage = result.data!.reduce((sum, unit) => sum + unit.usage, 0);

    return NextResponse.json({
      success: true,
      data: result.data,
      excelId,
      summary: {
        totalUnits: result.data!.length,
        totalUsage,
        averageUsage: totalUsage / result.data!.length,
      },
      warnings: result.warnings,
      message: 'Excel 파싱 및 저장이 완료되었습니다.',
    });
  } catch (error) {
    console.error('Excel upload error:', error);
    return NextResponse.json(
      { success: false, error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
```

#### 6.4 파싱 이력 조회 API (`app/api/parse/history/route.ts`)
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { ParseStorageService } from '@/lib/services/parse-storage';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const type = searchParams.get('type') as 'pdf' | 'excel' || 'pdf';
    const limit = parseInt(searchParams.get('limit') || '10');

    const storageService = new ParseStorageService();
    const history = await storageService.getParseHistory(type, limit);

    return NextResponse.json({
      success: true,
      data: history,
      type,
    });
  } catch (error: any) {
    console.error('History fetch error:', error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```

#### 6.5 월별 청구서 연결 API (`app/api/parse/link/route.ts`)
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { ParseStorageService } from '@/lib/services/parse-storage';

export async function POST(request: NextRequest) {
  try {
    const { pdfId, excelId, year, month } = await request.json();

    if (!pdfId || !excelId || !year || !month) {
      return NextResponse.json(
        { success: false, error: '필수 정보가 누락되었습니다.' },
        { status: 400 }
      );
    }

    const storageService = new ParseStorageService();
    const monthlyBillId = await storageService.linkToMonthlyBill(
      pdfId,
      excelId,
      year,
      month
    );

    return NextResponse.json({
      success: true,
      monthlyBillId,
      message: '월별 청구서가 생성되었습니다.',
    });
  } catch (error: any) {
    console.error('Link error:', error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```

### 7. 파일 업로드 컴포넌트

#### 7.1 업로드 컴포넌트 (`components/FileUpload.tsx`)
```typescript
'use client';

import { useState } from 'react';
import { Upload, FileText, AlertCircle } from 'lucide-react';

interface FileUploadProps {
  type: 'pdf' | 'excel';
  onUploadSuccess: (data: any) => void;
}

export function FileUpload({ type, onUploadSuccess }: FileUploadProps) {
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState('');
  const [warnings, setWarnings] = useState<string[]>([]);
  const [fileName, setFileName] = useState('');

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setError('');
    setWarnings([]);
    setFileName(file.name);
    setIsUploading(true);

    const formData = new FormData();
    formData.append(type, file);

    try {
      const response = await fetch(`/api/parse/${type}`, {
        method: 'POST',
        body: formData,
      });

      const result = await response.json();

      if (result.success) {
        onUploadSuccess(result.data);
        if (result.warnings) {
          setWarnings(result.warnings);
        }
      } else {
        setError(result.error);
      }
    } catch (error) {
      setError('파일 업로드 중 오류가 발생했습니다.');
    } finally {
      setIsUploading(false);
    }
  };

  const accept = type === 'pdf' ? '.pdf' : '.xlsx,.xls';
  const label = type === 'pdf' ? 'PDF 청구서' : 'Excel 사용량';

  return (
    <div className="border-2 border-dashed border-gray-300 rounded-lg p-6">
      <div className="text-center">
        <Upload className="mx-auto h-12 w-12 text-gray-400" />
        <div className="mt-4">
          <label htmlFor={`file-upload-${type}`} className="cursor-pointer">
            <span className="mt-2 block text-sm font-medium text-gray-900">
              {label} 업로드
            </span>
            <input
              id={`file-upload-${type}`}
              name={`file-upload-${type}`}
              type="file"
              className="sr-only"
              accept={accept}
              onChange={handleFileChange}
              disabled={isUploading}
            />
            <span className="mt-1 block text-xs text-gray-500">
              {type === 'pdf' ? 'PDF 파일만' : 'Excel 파일만'} (최대 10MB)
            </span>
          </label>
        </div>

        {fileName && (
          <div className="mt-4 flex items-center justify-center">
            <FileText className="h-5 w-5 text-gray-400 mr-2" />
            <span className="text-sm text-gray-600">{fileName}</span>
          </div>
        )}

        {isUploading && (
          <div className="mt-4">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
            <p className="mt-2 text-sm text-gray-600">파일 처리 중...</p>
          </div>
        )}

        {error && (
          <div className="mt-4 bg-red-50 border border-red-200 rounded-md p-4">
            <div className="flex">
              <AlertCircle className="h-5 w-5 text-red-400" />
              <div className="ml-3">
                <p className="text-sm text-red-800">{error}</p>
              </div>
            </div>
          </div>
        )}

        {warnings.length > 0 && (
          <div className="mt-4 bg-yellow-50 border border-yellow-200 rounded-md p-4">
            <div className="flex">
              <AlertCircle className="h-5 w-5 text-yellow-400" />
              <div className="ml-3">
                <p className="text-sm font-medium text-yellow-800">경고</p>
                <ul className="mt-1 text-sm text-yellow-700 list-disc list-inside">
                  {warnings.map((warning, index) => (
                    <li key={index}>{warning}</li>
                  ))}
                </ul>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
```

## 테스트 체크리스트

- [ ] PDF 파일 업로드 및 파싱 성공
- [ ] Excel 파일 업로드 및 파싱 성공
- [ ] 파싱된 데이터 DB 저장 확인 (parsed_pdf_data 테이블)
- [ ] 파싱된 데이터 DB 저장 확인 (parsed_excel_data 테이블)
- [ ] 중복 파일 업로드 방지 (SHA256 해시 체크)
- [ ] 파싱 이력 조회 API 동작 확인
- [ ] 월별 청구서 연결 기능 확인
- [ ] 다양한 형식의 한전 청구서 처리
- [ ] 다양한 Excel 템플릿 지원
- [ ] 대용량 파일 처리 (10MB)
- [ ] 잘못된 파일 형식 거부
- [ ] 파싱 실패 시 에러 처리
- [ ] 데이터 검증 및 경고 표시
- [ ] 메모리 누수 없음 확인

## 성능 최적화

1. **스트리밍 처리**
   - 대용량 파일은 스트림으로 처리
   - 메모리 사용량 최소화

2. **비동기 처리**
   - 파싱 작업을 비동기로 처리
   - 타임아웃 설정 (30초)

3. **캐싱**
   - 파싱 결과 임시 캐싱
   - 중복 파싱 방지

## 보안 고려사항

1. **파일 검증**
   - 파일 타입 확인
   - 파일 크기 제한
   - 악성 코드 스캔

2. **데이터 보호**
   - 파일 내용 로깅 금지
   - 메모리에서만 처리
   - 처리 후 즉시 삭제

3. **접근 제어**
   - 관리자만 업로드 가능
   - Rate limiting 적용

## 예상 소요 시간
- PDF 파서 구현: 3시간
- Excel 파서 구현: 2시간
- API 엔드포인트: 2시간
- 업로드 컴포넌트: 2시간
- 테스트 및 디버깅: 3시간
- **총 예상 시간: 12시간**

## 다음 단계
Phase 3: 계산 엔진 구현으로 진행